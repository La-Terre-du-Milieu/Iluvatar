client.on('message', message => {

  const args = message.content.slice(prefix.length).trim().split(/ +/);
	const command = args.shift().toLowerCase();
  // const commandName = args.shift().toLowerCase();


    // if (message.author.bot) return;
    // if (!message.content.startsWith(prefix)) return;

    // try {
    //     command.execute(message);
    // } catch (error) {
    //   console.error(error);
    //   message.reply('There was an error trying to execute that command!');
    // }

	// if (message.content === `${prefix}server`) {
    //     message.channel.send(`This server's name is: ${message.guild.name}`);
    // }
    // else if (message.content === `${prefix}avatar`) {
    //     if (!message.mentions.users.size) {
    //         return message.channel.send(`<${message.author.displayAvatarURL({ format: "png", dynamic: true })}>`);
    //     }
    
    //     const avatarList = message.mentions.users.map(user => {
    //         return `${user.username} : <${user.displayAvatarURL({ format: "png", dynamic: true })}>`;
    //     });
    
    //     // send the entire array of strings as a message
    //     // by default, discord.js will `.join()` the array with `\n`
    //     message.channel.send(avatarList);
    // }
    // else if (message.content === '<:Gandoulf:678592029093134348>') {
	// 	message.react('678592029093134348');
	// }
    
    
    // if (message.content === '<:Arnor:710969959819509830>') {
	// 	message.channel.send('<:Arnor:710969959819509830>');
	// }

    // if (message.content === '<:rohan:646704340551073842>') {
    //     message.channel.send('<:rohan:646704340551073842>');
    // }

    // if (message.content === 'OU ETAIT LE GONDOR QUAND L OUESTFOLD EST  TOMBU ??') {
    //     // Send "pong" to the same channel
    //     message.channel.send('Le Gondor était occupé à Cair Andros');
    // }

    if (message.content === 'OU ETAIT LE GONDOR QUAND L OUESTFOLD EST  TOMBU ??' ||
    message.content === 'gondor') {
        // Send "pong" to the same channel
        message.channel.send('Le Gondor était occupé à Cair Andros');
    }

    if (message.content === 'citation') {
      const citation = [
        "Vous ne passerez pas !",
        "Une mort certaine. Une faible chance de succès. Mais qu’attendons-nous ?",
        "Ça ne compte quand même que pour un !",
        "Stupide hobbit joufflu !",
        "Je préfère partager une vie de mortelle avec vous que de devoir affronter tous les ages de ce monde toute seule.",
        "Je suis un serviteur du Feu Secret, détenteur de la flamme d’Anor. Le feu sombre ne vous servira à rien, flamme d’Udûn. Repartez dans l’ombre ! Vous ne passerez pas !",
        "Il est fort dangereux Frodon de sortir de chez soi, on prend la route et si on ne regarde pas où l’on met les pieds on ne sait pas jusque où cela peut nous mener.",
        "Et bien, c’est plus gai dans un cimetière…",
        "Fuyez, pauvres fous !",
        "Beaucoup de choses existaient jadis mais aucun de ceux qui vivent aujourd’hui ne s’en souviennent."
      ]
      message.channel.send(citation[Math.floor(Math.random() * citation.length)])
    }



    //BAOUI COMMAND 

    if (message.content === "basoui") {
      const factions = [
        "Bobby", "Elfe", "Rohan", "Nain", "Gondor", "Mordor", "Isengard", "Gobelin", "Angmar", "<:gollum:646777565469736960>"
      ]
      let best = factions[Math.floor(Math.random() * factions.length)];
      let phrase;
      switch (best) {
        case "Elfe":
          phrase = "Le plus beau"
          break;
        case "Nain":
          phrase = "un petit gras barbu"
          break;
        default:
          phrase = best
          break;
      }
      message.channel.send('Tu es né pour être ' + phrase)
    }

    
    //BAOUI COMMAND

    if (message.content === "newchannel" && message.member.roles.cache.has('646687065597149189')) {
      message.guild.channels.create('Test', { //Create a channel
        type: 'text', //Make sure the channel is a text channel
        permissionOverwrites: [{ //Set permission overwrites
            id: message.guild.id,
            allow: ['VIEW_CHANNEL'],
        }],
        parent: '745263077821251715'
      });
      message.channel.send("Channel Created!")
    }

    if(message.content === "json") {
      let settings = { method: "Get" };

      fetch("https://api.npoint.io/30c5deeefc17427a8cd7/7", settings)
          .then(res => res.json())
          .then((json) => {
              console.log(json.matchs)
              for (let m = 0; m < json.matchs.length; m++) {
                const element = json.matchs[m];

                message.guild.channels.create(element.map, { //Create a channel
                  type: 'text', //Make sure the channel is a text channel
                  permissionOverwrites: [{ //Set permission overwrites
                      id: message.guild.id,
                      allow: ['VIEW_CHANNEL'],
                  }],
                  parent: '745263077821251715'
                });
                message.channel.send("Channel Created!" + element.map)


                console.log(element)
                console.log(client.users.get('name', 'TK').id)
                
              }
              // message.channel.send(json)
          });
    }



    // if (message.content === '<:tw:646809607037124611>') {
    //     message.channel.send('<:tw:646809607037124611> ')
    //     message.channel.send('<:tw:646809607037124611> ')
    //     message.channel.send('TOWER')
    // }

    // if (!message.content.startsWith(prefix) || message.author.bot) return;



	if (message.content === 'ping') {
		message.channel.send('pong')
	} 

    console.log(command)
    console.log(args)
    if (command === 'rotwk') {

        message.delete({ timeout: 100 });
        // if (!args[0]) return message.reply('You need to supply the question');

        let title = '';
        let nb = 8;

        if (command === 'rotwk') {
            title = "L'Avènement du Roi Sorcier"
        }

        if (args[0]) {
            nb = args[0]
        }
        else {
            nb = 8
        }

        console.log(args)
        
        let embed = new Discord.MessageEmbed()
          .setTitle(title)
          .setDescription('Création de la partie part de ' + message.author.tag)
          .addField('Statue', 'En cours de réparation.')
          .addField('Vocal de la partie', 'https://discord.gg/y5KdfNTZHA')
          .setColor('#1DD1EA')
          .attachFiles(new Discord.MessageAttachment('https://media.moddb.com/images/members/1/365/364637/profile/RotWK_HD_Logo_Renders.png', 'thumbnail.png'))
          .setThumbnail('attachment://thumbnail.png')
          .setFooter('Eru Ilúvatar');
        
        message.channel.send(embed).then(async msg => {
            await msg.react('👍');
        
          const threshold = nb;
        
          async function stop() {
            collector.stop();
        
            const newEmbed = new Discord.MessageEmbed(msg.embeds[0]);
        
            newEmbed.title = newEmbed.title + ' [FERMER]';
            newEmbed.fields[0] = { name: 'Statue', value: 'Game en cours.' };
            newEmbed.setThumbnail('attachment://thumbnail.png');
            await msg.edit(newEmbed);
        
            msg.reactions.removeAll();
          }
        
          async function update() {
            const newEmbed = new Discord.MessageEmbed(embed);
        
            const userYes = (votes['👍'].size === 0)? '-' : [...votes['👍']];
        
            newEmbed.addFields(
              { name: `Participants : (${votes['👍'].size}/${threshold})`, value: userYes, inline: true }
            );
        
            await msg.edit(newEmbed);
        
            if (votes['👍'].size >= threshold) {
              await stop();
            }
          }
        
          const votes = {
            '👍': new Set()
          };
        
          update();
        
          const collector = msg.createReactionCollector((reaction, user) => !user.bot , { dispose: true });

            collector.on('collect', async (reaction, user) => {
                if (['👍'].includes(reaction.emoji.name)) {
                const userReactions = msg.reactions.cache.filter(reaction => reaction.users.cache.has(user.id));

                for (const userReaction of userReactions.values()) {
                    if (userReaction.emoji.name !== reaction.emoji.name) {
                    userReaction.users.remove(user.id);
                    votes[userReaction.emoji.name].delete(user);
                    }
                }

                votes[reaction.emoji.name].add(user);
                } else {
                reaction.remove();
                }

                update();
            });

            collector.on('remove', (reaction, user) => {
                votes[reaction.emoji.name].delete(user);

                update();
            });
        });
    }