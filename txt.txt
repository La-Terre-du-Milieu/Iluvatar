client.on('message', message => {

  const args = message.content.slice(prefix.length).trim().split(/ +/);
	const command = args.shift().toLowerCase();
  // const commandName = args.shift().toLowerCase();


    // if (message.author.bot) return;
    // if (!message.content.startsWith(prefix)) return;

    // try {
    //     command.execute(message);
    // } catch (error) {
    //   console.error(error);
    //   message.reply('There was an error trying to execute that command!');
    // }

	// if (message.content === `${prefix}server`) {
    //     message.channel.send(`This server's name is: ${message.guild.name}`);
    // }
    // else if (message.content === `${prefix}avatar`) {
    //     if (!message.mentions.users.size) {
    //         return message.channel.send(`<${message.author.displayAvatarURL({ format: "png", dynamic: true })}>`);
    //     }
    
    //     const avatarList = message.mentions.users.map(user => {
    //         return `${user.username} : <${user.displayAvatarURL({ format: "png", dynamic: true })}>`;
    //     });
    
    //     // send the entire array of strings as a message
    //     // by default, discord.js will `.join()` the array with `\n`
    //     message.channel.send(avatarList);
    // }
    // else if (message.content === '<:Gandoulf:678592029093134348>') {
	// 	message.react('678592029093134348');
	// }
    
    
    // if (message.content === '<:Arnor:710969959819509830>') {
	// 	message.channel.send('<:Arnor:710969959819509830>');
	// }

    // if (message.content === '<:rohan:646704340551073842>') {
    //     message.channel.send('<:rohan:646704340551073842>');
    // }

    // if (message.content === 'OU ETAIT LE GONDOR QUAND L OUESTFOLD EST  TOMBU ??') {
    //     // Send "pong" to the same channel
    //     message.channel.send('Le Gondor Ã©tait occupÃ© Ã  Cair Andros');
    // }

    if (message.content === 'OU ETAIT LE GONDOR QUAND L OUESTFOLD EST  TOMBU ??' ||
    message.content === 'gondor') {
        // Send "pong" to the same channel
        message.channel.send('Le Gondor Ã©tait occupÃ© Ã  Cair Andros');
    }

    if (message.content === 'citation') {
      const citation = [
        "Vous ne passerez pas !",
        "Une mort certaine. Une faible chance de succÃ¨s. Mais quâ€™attendons-nous ?",
        "Ã‡a ne compte quand mÃªme que pour un !",
        "Stupide hobbit joufflu !",
        "Je prÃ©fÃ¨re partager une vie de mortelle avec vous que de devoir affronter tous les ages de ce monde toute seule.",
        "Je suis un serviteur du Feu Secret, dÃ©tenteur de la flamme dâ€™Anor. Le feu sombre ne vous servira Ã  rien, flamme dâ€™UdÃ»n. Repartez dans lâ€™ombre ! Vous ne passerez pas !",
        "Il est fort dangereux Frodon de sortir de chez soi, on prend la route et si on ne regarde pas oÃ¹ lâ€™on met les pieds on ne sait pas jusque oÃ¹ cela peut nous mener.",
        "Et bien, câ€™est plus gai dans un cimetiÃ¨reâ€¦",
        "Fuyez, pauvres fous !",
        "Beaucoup de choses existaient jadis mais aucun de ceux qui vivent aujourdâ€™hui ne sâ€™en souviennent."
      ]
      message.channel.send(citation[Math.floor(Math.random() * citation.length)])
    }



    //BAOUI COMMAND 

    if (message.content === "basoui") {
      const factions = [
        "Bobby", "Elfe", "Rohan", "Nain", "Gondor", "Mordor", "Isengard", "Gobelin", "Angmar", "<:gollum:646777565469736960>"
      ]
      let best = factions[Math.floor(Math.random() * factions.length)];
      let phrase;
      switch (best) {
        case "Elfe":
          phrase = "Le plus beau"
          break;
        case "Nain":
          phrase = "un petit gras barbu"
          break;
        default:
          phrase = best
          break;
      }
      message.channel.send('Tu es nÃ© pour Ãªtre ' + phrase)
    }

    
    //BAOUI COMMAND

    if (message.content === "newchannel" && message.member.roles.cache.has('646687065597149189')) {
      message.guild.channels.create('Test', { //Create a channel
        type: 'text', //Make sure the channel is a text channel
        permissionOverwrites: [{ //Set permission overwrites
            id: message.guild.id,
            allow: ['VIEW_CHANNEL'],
        }],
        parent: '745263077821251715'
      });
      message.channel.send("Channel Created!")
    }

    if(message.content === "json") {
      let settings = { method: "Get" };

      fetch("https://api.npoint.io/30c5deeefc17427a8cd7/7", settings)
          .then(res => res.json())
          .then((json) => {
              console.log(json.matchs)
              for (let m = 0; m < json.matchs.length; m++) {
                const element = json.matchs[m];

                message.guild.channels.create(element.map, { //Create a channel
                  type: 'text', //Make sure the channel is a text channel
                  permissionOverwrites: [{ //Set permission overwrites
                      id: message.guild.id,
                      allow: ['VIEW_CHANNEL'],
                  }],
                  parent: '745263077821251715'
                });
                message.channel.send("Channel Created!" + element.map)


                console.log(element)
                console.log(client.users.get('name', 'TK').id)
                
              }
              // message.channel.send(json)
          });
    }



    // if (message.content === '<:tw:646809607037124611>') {
    //     message.channel.send('<:tw:646809607037124611> ')
    //     message.channel.send('<:tw:646809607037124611> ')
    //     message.channel.send('TOWER')
    // }

    // if (!message.content.startsWith(prefix) || message.author.bot) return;



	if (message.content === 'ping') {
		message.channel.send('pong')
	} 

    console.log(command)
    console.log(args)
    if (command === 'rotwk') {

        message.delete({ timeout: 100 });
        // if (!args[0]) return message.reply('You need to supply the question');

        let title = '';
        let nb = 8;

        if (command === 'rotwk') {
            title = "L'AvÃ¨nement du Roi Sorcier"
        }

        if (args[0]) {
            nb = args[0]
        }
        else {
            nb = 8
        }

        console.log(args)
        
        let embed = new Discord.MessageEmbed()
          .setTitle(title)
          .setDescription('CrÃ©ation de la partie part de ' + message.author.tag)
          .addField('Statue', 'En cours de rÃ©paration.')
          .addField('Vocal de la partie', 'https://discord.gg/y5KdfNTZHA')
          .setColor('#1DD1EA')
          .attachFiles(new Discord.MessageAttachment('https://media.moddb.com/images/members/1/365/364637/profile/RotWK_HD_Logo_Renders.png', 'thumbnail.png'))
          .setThumbnail('attachment://thumbnail.png')
          .setFooter('Eru IlÃºvatar');
        
        message.channel.send(embed).then(async msg => {
            await msg.react('ðŸ‘');
        
          const threshold = nb;
        
          async function stop() {
            collector.stop();
        
            const newEmbed = new Discord.MessageEmbed(msg.embeds[0]);
        
            newEmbed.title = newEmbed.title + ' [FERMER]';
            newEmbed.fields[0] = { name: 'Statue', value: 'Game en cours.' };
            newEmbed.setThumbnail('attachment://thumbnail.png');
            await msg.edit(newEmbed);
        
            msg.reactions.removeAll();
          }
        
          async function update() {
            const newEmbed = new Discord.MessageEmbed(embed);
        
            const userYes = (votes['ðŸ‘'].size === 0)? '-' : [...votes['ðŸ‘']];
        
            newEmbed.addFields(
              { name: `Participants : (${votes['ðŸ‘'].size}/${threshold})`, value: userYes, inline: true }
            );
        
            await msg.edit(newEmbed);
        
            if (votes['ðŸ‘'].size >= threshold) {
              await stop();
            }
          }
        
          const votes = {
            'ðŸ‘': new Set()
          };
        
          update();
        
          const collector = msg.createReactionCollector((reaction, user) => !user.bot , { dispose: true });

            collector.on('collect', async (reaction, user) => {
                if (['ðŸ‘'].includes(reaction.emoji.name)) {
                const userReactions = msg.reactions.cache.filter(reaction => reaction.users.cache.has(user.id));

                for (const userReaction of userReactions.values()) {
                    if (userReaction.emoji.name !== reaction.emoji.name) {
                    userReaction.users.remove(user.id);
                    votes[userReaction.emoji.name].delete(user);
                    }
                }

                votes[reaction.emoji.name].add(user);
                } else {
                reaction.remove();
                }

                update();
            });

            collector.on('remove', (reaction, user) => {
                votes[reaction.emoji.name].delete(user);

                update();
            });
        });
    }